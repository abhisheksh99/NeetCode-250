# 15. 3Sum
**Medium**

## Problem Statement
Given an integer array `nums`, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.
Notice that the solution set must not contain duplicate triplets.

## Examples
### Example 1:
- Input: nums = [-1,0,1,2,-1,-4]
- Output: [[-1,-1,2],[-1,0,1]]

### Example 2:
- Input: nums = [0,1,1]
- Output: []

### Example 3:
- Input: nums = [0,0,0]
- Output: [[0,0,0]]

## Constraints
- 3 <= nums.length <= 3000
- -10^5 <= nums[i] <= 10^5

## Solution
```java
class Solution {
	public List<List<Integer>> threeSum(int[] nums) {
		Arrays.sort(nums); // Sort the array
		List<List<Integer>> result = new ArrayList<>();

		// Iterate through the array
		for (int i = 0; i < nums.length && nums[i] <= 0; i++) {
			// Skip duplicates
			if (i == 0 || nums[i] != nums[i - 1]) {
				twoSum2(nums, i, result);
			}
		}
		return result;
	}

	private void twoSum2(int[] nums, int i, List<List<Integer>> result) {
		int left = i + 1;
		int right = nums.length - 1;

		while (left < right) {
			int sum = nums[i] + nums[left] + nums[right];
			if (sum < 0) {
				left++;
			} else if (sum > 0) {
				right--;
			} else {
				// Add the triplet to the result list
				result.add(Arrays.asList(nums[i], nums[left], nums[right]));

				// Skip duplicates for `left` and `right`
				while (left < right && nums[left] == nums[left + 1]) left++;
				while (left < right && nums[right] == nums[right - 1]) right--;

				// Move pointers inward
				left++;
				right--;
			}
		}
	}
}
```

Approach

- Sort the input array to enable the two-pointer technique and easy duplicate skipping.
- Iterate through the array, fixing one element at a time.
- For each fixed element, use two pointers (`left` and `right`) to find pairs that sum to the negative of the fixed element.
- Skip duplicate elements to avoid duplicate triplets in the result.
- Add valid triplets to the result list.
- Notes: Sorting and duplicate checks are key to efficiency and correctness.

Time Complexity

O(n^2), where n is the length of the array (due to nested iteration and two-pointer search).

Space Complexity

O(1) (excluding the output list), as the algorithm uses only a few pointers and variables.
