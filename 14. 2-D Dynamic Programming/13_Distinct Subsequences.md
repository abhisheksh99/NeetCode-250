# 115. Distinct Subsequences

## Problem Statement
Given two strings `s` and `t`, return the number of distinct subsequences of `s` which equals `t`.

A string's subsequence is a new string generated by deleting some (can be none) of the characters without changing the relative order of the remaining characters.

## Examples

### Example 1:
```
Input: s = "rabbbit", t = "rabbit"
Output: 3
Explanation:
As shown below, there are 3 ways to get "rabbit" from "rabbbit".
rabbbit
rabbbit
rabbbit
```

### Example 2:
```
Input: s = "babgbag", t = "bag"
Output: 5
Explanation:
As shown below, there are 5 ways to get "bag" from "babgbag".
babgbag
babgbag
babgbag
babgbag
babgbag
```

## Approach
We use dynamic programming to solve this problem:
1. Create a 2D DP array where `dp[i][j]` represents the number of distinct subsequences of `s[0...i-1]` that equals `t[0...j-1]`
2. Initialize `dp[i][0] = 1` for all `i` because there's exactly one way to get an empty string from any string (delete all characters)
3. If `s[i-1] == t[j-1]`, we have two choices:
   - Match the current characters: `dp[i-1][j-1]`
   - Skip the current character in `s`: `dp[i-1][j]`
4. If `s[i-1] != t[j-1]`, we can only skip the current character in `s`
5. The answer will be in `dp[m][n]` where `m` is the length of `s` and `n` is the length of `t`

## Solution Code
```java
class Solution {
    public int numDistinct(String s, String t) {
        int m = s.length();
        int n = t.length();
        
        // Create a 2D dp array
        int[][] dp = new int[m + 1][n + 1];

        // Initialize dp[i][0] = 1 for all i
        // There's one way to form empty string from any string (delete all characters)
        for (int i = 0; i <= m; i++) {
            dp[i][0] = 1;
        }

        // Fill the dp array
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (s.charAt(i - 1) == t.charAt(j - 1)) {
                    // If characters match, we can either take this character or skip it
                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
                } else {
                    // If characters don't match, we can only skip this character in s
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }

        // Return the result
        return dp[m][n];
    }
}
```

## Complexity Analysis
- **Time Complexity**: O(m × n) - We fill a 2D array of size (m+1) × (n+1)
- **Space Complexity**: O(m × n) - For the DP table

## Key Insights
1. **DP State Definition**: `dp[i][j]` represents the number of ways to form `t[0...j-1]` from `s[0...i-1]`
2. **Base Case**: There's exactly one way to form an empty string from any string
3. **State Transition**: 
   - When characters match, we can either take the match or skip it
   - When characters don't match, we can only skip the current character in `s`
4. **Result Extraction**: The answer is in the bottom-right cell of the DP table

## Edge Cases
1. Empty target string (should return 1)
2. Empty source string with non-empty target (should return 0)
3. Both strings are the same (should return 1)
4. No possible subsequence (should return 0)
5. Multiple occurrences of the same character

## Follow-up
How would you modify the solution to handle very large inputs where the answer fits in a 32-bit signed integer, but the number of operations might be large? (Hint: Consider space optimization)