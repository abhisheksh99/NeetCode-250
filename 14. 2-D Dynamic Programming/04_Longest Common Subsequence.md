# 1143. Longest Common Subsequence

## Problem Statement
Given two strings `text1` and `text2`, return the length of their longest common subsequence. If there is no common subsequence, return 0.

A subsequence of a string is a new string generated by deleting some or no characters without changing the relative order of the remaining characters.

## Examples

### Example 1:
```
Input: text1 = "abcde", text2 = "ace" 
Output: 3  
Explanation: The longest common subsequence is "ace" and its length is 3.
```

### Example 2:
```
Input: text1 = "abc", text2 = "abc"
Output: 3
Explanation: The longest common subsequence is "abc" and its length is 3.
```

### Example 3:
```
Input: text1 = "abc", text2 = "def"
Output: 0
Explanation: There is no such common subsequence.
```

## Approach
We use dynamic programming with a bottom-up approach:
1. Create a DP table with dimensions (m+1) x (n+1) where m and n are lengths of text1 and text2
2. Initialize all values to 0 (handled by default in Java)
3. Traverse both strings from the end to the beginning
4. If characters match, take diagonal value + 1
5. If characters don't match, take maximum of right or bottom cell
6. The result is stored in dp[0][0]

## Solution Code
```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length();
        int n = text2.length();
        int[][] dp = new int[m + 1][n + 1];
        
        // Fill the DP table from bottom-right to top-left
        for (int i = m - 1; i >= 0; i--) {
            for (int j = n - 1; j >= 0; j--) {
                if (text1.charAt(i) == text2.charAt(j)) {
                    // If characters match, take diagonal value + 1
                    dp[i][j] = 1 + dp[i + 1][j + 1];
                } else {
                    // If characters don't match, take maximum of right or bottom cell
                    dp[i][j] = Math.max(dp[i + 1][j], dp[i][j + 1]);
                }
            }
        }
        
        return dp[0][0];  // The result is stored in the top-left cell
    }
}
```

## Complexity Analysis
- **Time Complexity**: O(m×n) - We process each character pair exactly once
- **Space Complexity**: O(m×n) - For the DP table (can be optimized to O(min(m, n)) using 1D array)

## Space Optimization
We can optimize the space to O(min(m, n)) by using a 1D array:
```java
public int longestCommonSubsequence(String text1, String text2) {
    // Make sure text2 is the shorter string to minimize space
    if (text1.length() < text2.length()) {
        return longestCommonSubsequence(text2, text1);
    }
    
    int m = text1.length();
    int n = text2.length();
    int[] dp = new int[n + 1];
    
    for (int i = m - 1; i >= 0; i--) {
        int prev = 0;
        for (int j = n - 1; j >= 0; j--) {
            int temp = dp[j];
            if (text1.charAt(i) == text2.charAt(j)) {
                dp[j] = 1 + prev;
            } else {
                dp[j] = Math.max(dp[j], dp[j + 1]);
            }
            prev = temp;
        }
    }
    
    return dp[0];
}
```

## Key Insights
1. **Bottom-up DP**: Solves smaller subproblems first and builds up to the solution
2. **State Transition**:
   - Match: dp[i][j] = 1 + dp[i+1][j+1]
   - No Match: dp[i][j] = max(dp[i+1][j], dp[i][j+1])
3. **Direction of Iteration**: We process from the end of both strings to the beginning
4. **Space Optimization**: Only the current and previous rows are needed at any point

## Edge Cases
1. One or both strings are empty
2. Strings are identical
3. No common subsequence exists
4. One string is a subsequence of the other
5. Large input strings (tests efficiency)

## Follow-up
How would you modify the solution to return the actual longest common subsequence string instead of just its length?